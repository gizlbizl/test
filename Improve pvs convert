param (
    [string]$connectorCfgName,  # Параметр извне
    [string]$imageName,         # Параметр извне
    [string]$osType,            # Параметр извне
    [string]$diskLocatorId      # Параметр извне
)

# Внутренние настройки
$ScriptFolder = "C:\Scripts"
$bConvertToVHDX = $true
$bCheckForSpace = $true
$QEMUPATH = "C:\Scripts\qemu-img.exe"
$VHDXSubformat = "dynamic"
$bUSE_Versioning = $true
$bUseImageNameAsvDiskName = $true
$LOG_FILE = "$ScriptFolder\pvs_connector_script.log"

# Уровни логирования
enum LogLevel {
    INFO
    WARNING
    ERROR
}

# Функция логирования
function Log {
    param(
        [string]$Message,
        [LogLevel]$Level = [LogLevel]::INFO
    )
    $logEntry = "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] [$Level] $Message"
    $logEntry | Out-File -FilePath $LOG_FILE -Append -Force
    Write-Host $logEntry
}

# Функция проверки свободного места (работает с локальными и сетевыми дисками)
function Get-FreeSpace {
    param (
        [string]$Path
    )
    try {
        if ($Path -match '^\\\\') {
            # Для сетевых путей (CIFS/SMB)
            $drive = (Get-SmbConnection -RemotePath $Path -ErrorAction Stop).RemotePath
        } else {
            # Для локальных путей
            $drive = (Get-Item $Path).Root
        }
        $driveInfo = [System.IO.DriveInfo]::new($drive)
        return $driveInfo.AvailableFreeSpace
    } catch {
        Log "Failed to get free space for path: $Path" -Level ERROR
        throw
    }
}

# Функция конвертации VHD в VHDX
function Convert-VHDtoVHDX {
    param (
        [string]$VHDPath,
        [string]$VHDXPath,
        [string]$QEMUPATH,
        [string]$VHDXSubformat
    )
    try {
        Log "Converting VHD to VHDX: $VHDPath -> $VHDXPath"
        Invoke-Expression "$QEMUPATH convert -O vhdx `"$VHDPath`" `"$VHDXPath`" -o subformat=$VHDXSubformat"
        if (-not (Test-Path $VHDXPath)) {
            throw "Conversion failed: VHDX file not found."
        }
        Log "Conversion successful."
    } catch {
        Log "Failed to convert VHD to VHDX: $_" -Level ERROR
        throw
    }
}

# Основной скрипт
try {
    Log "Starting script execution."
    Log "Parameters received:"
    Log "  - connectorCfgName: $connectorCfgName"
    Log "  - imageName: $imageName"
    Log "  - osType: $osType"
    Log "  - diskLocatorId: $diskLocatorId"

    # Получение информации о диске
    $MyVHDDiskLocator = Get-PVSDisklocator -DiskLocatorId $diskLocatorId
    if (-not $MyVHDDiskLocator) {
        throw "Failed to get disk locator for ID: $diskLocatorId"
    }

    $storePath = (Get-PvsStore -StoreId $MyVHDDiskLocator.StoreId).Path
    Log "Store path: $storePath"

    $MyVHDpath = (Get-PvsDisk -DiskLocatorId $diskLocatorId).OriginalFile
    if (-not $MyVHDpath) {
        throw "Failed to find the imported vDisk."
    }

    Log "Original vDisk path: $MyVHDpath"

    # Проверка и конвертация VHD/VHDX
    $inputFileExtension = [System.IO.Path]::GetExtension($MyVHDpath)
    if ($inputFileExtension -eq ".vhdx") {
        Log "Input file is already VHDX. No conversion needed."
    } elseif ($bConvertToVHDX) {
        $MyVHD = Get-Item -Path $MyVHDpath
        $MyVHDBaseName = $MyVHD.BaseName
        $MyVHDXName = "$MyVHDBaseName.vhdx"
        $MyVHDXPath = Join-Path -Path $storePath -ChildPath $MyVHDXName

        if ($bCheckForSpace) {
            $MyVHDsize = $MyVHD.Length
            $StoreFreeSpace = Get-FreeSpace -Path $storePath
            if ($StoreFreeSpace -lt $MyVHDsize) {
                throw "Insufficient space on store to convert VHD to VHDX."
            }
            Log "Sufficient space available for conversion."
        }

        Convert-VHDtoVHDX -VHDPath $MyVHDpath -VHDXPath $MyVHDXPath -QEMUPATH $QEMUPATH -VHDXSubformat $VHDXSubformat
    }

    # Логика для работы с версиями (если включено)
    if ($bUSE_Versioning) {
        Log "Versioning is enabled."
        # Дополнительная логика для работы с версиями...
    }

    Log "Script completed successfully."
} catch {
    Log "Script failed: $_" -Level ERROR
    exit 1
}
